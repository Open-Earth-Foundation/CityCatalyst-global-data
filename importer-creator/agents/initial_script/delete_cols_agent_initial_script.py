import sys
import subprocess
import json
import pandas as pd
from state.agent_state import AgentState
from utils.create_prompt import create_prompt
from utils.agent_factory import AgentFactory
from context.mappings.mappings_white_list import white_list_mapping
from utils.create_descriptive_stats_prompt import create_descriptive_stats_prompt
from utils.output_path_updater import update_output_path


def delete_cols_agent_initial_script(
    state: AgentState,
):
    """
    This agent is responsible for deleting unneccesary columns.

    Inputs:
        Input path to the csv file created by the prior agent.
        The dataframe loaded from the input path.
        White list of columns that cannot be deleted.
        The python script generated by the prior agent.
    """
    print("\nDELETE COLUMNS AGENT INITIAL SCRIPT\n")

    # Load the previously created formatted csv file into a pandas dataframe
    input_path_csv = "./generated/initial_script/steps/1_initially.csv"
    input_path_script = "./generated/initial_script/steps/1_initially.py"

    # Load the dataframe and the script
    df = pd.read_csv(input_path_csv, encoding="utf-8", sep=",", decimal=".")

    # Get pre-initialized agents from the AgentFactory
    structured_output_agent = AgentFactory.get_structured_output_agent(
        state.get("verbose")
    )
    agent = AgentFactory.get_coding_agent(df, state.get("verbose"))

    descriptive_statistics = create_descriptive_stats_prompt(df)

    # Load the script
    with open(input_path_script, "r", encoding="utf-8") as file:
        script = file.read()

    # Define the output paths
    output_path_csv = "./generated/initial_script/steps/2_deleted_columns.csv"
    output_path_script = "./generated/initial_script/steps/2_deleted_columns.py"
    output_path_markdown = "./generated/initial_script/steps/2_deleted_columns.md"

    # Create the prompt
    task = """
Your task is to inspect the dataframe 'df' and to keep all necessary columns based on the provided information in <white_list> tags below. You will also create a runnable python script.
Your inputs are:
- the input path to the .csv file created by the prior agent under <input_path> tags below.
- the dataframe 'df' loaded from the .csv file created by the prior agent.
- information about which columns are necessary and cannot be deleted (white list) in <white_list> tags below.
- the python script created by the prior agent provided below inside <prior_script> tags
"""

    completion_steps = f"""
a. Inspect the .csv file provided under <input_path> tags below. The dataframe 'df' you are provided with is the result of running the python script under <prior_script> tags below on this input .csv file.
    - Load the .csv file into a pandas dataframe 'df' using the path provided under <input_path> tags and 'df = pd.read_csv(input_path, encoding="utf-8", sep=",")'.
    - **NEVER** load the .csv file saved in the 'original_path' variable inside the script under <prior_script> tags.  
b. Inspect the white list of columns which are necessary under <white_list> tags.
c. Output a list of columns that are not necessary and can be deleted. Unnecessary columns are columns that are empty or which are not included in the white list provided under <white_list> tags. Make sure to not attempt to delete the same column multiple times, e.g. because it is empty and it is not in the white list. If you are in doubt about a certain column, do not delete it and flag it for further inspection in your reasoning.
d. Inspect the provided python script under <prior_script> tags.
e. Update the provided python script in <prior_script> tags below. This python script must contain the following:
    1. the original code of the prior script provided in the <prior_script> tags below. You make your changes to this script. 
    2. delete all columns from the dataframe 'df_new' that are not necessary, based on your analysis of the white list provided under <white_list> tags below. 
    3. Insert the new code at the bottom of the script and before the final output to csv, to keep the chronological order of the script.
    
    IMPORTANT: 
    - **DO NOT** load the .csv file saved in the 'original_path' variable inside the script under <prior_script> tags below. You only work with the dataframe 'df' you are already provided with.
    - The code must contain python comments explaining the code.
    - The code must be executable and must not contain any code errors.
    - The new script must contain all the content of the initial script in addition to the added data. 
"""

    answer_format = """
Your output must be provided in JSON format. Provide all detailed reasoning in a structured and human readable way (e.g. using sub headers, bulletpoints and numbered lists) and the pure executable Python code in the following JSON format:
{
    "reasoning": "Your detailed reasoning here...",
    "code": "Your pure executable Python code here..."
}
Ensure that the output is valid JSON and does not include any additional commentary or explanation. Do not surround the JSON output with any code block markers or tags like ```json```.
"""

    additional_information = f"""
<additional_information>
<input_path>
This is the input path to the .csv file created by the prior agent: {input_path_csv}
</input_path>
<white_list>
This is the white list of columns with descriptions. For each column name, inspect the description and the examples and use them as reference for deciding on which columns to keep. Include a reference to the descriptions and examples in your reasoning.
This whitelist contains the necessary columns: {json.dumps(white_list_mapping, indent=4)}
</white_list>
<prior_script>
This is the prior python script provided:
    
```python
{script}
```
</prior_script>
</additional_information>
"""

    prompt = create_prompt(
        task, completion_steps, answer_format, additional_information
    )

    # Invoke summary agent with custom prompt
    response = agent.invoke(descriptive_statistics + prompt)
    response_output = response.get("output")

    # Invoke the new structured output agent with the parsing task
    structured_output = structured_output_agent.invoke(response_output)

    ### Code below for extracting the code from the agent's response and running it - creating the csv file ###
    # Function to parse the JSON response from the agent
    def parse_agent_response(response):
        try:
            # Load the pydantic object into JSON
            response_json = response.json()
            # Load the JSON into a dictionary
            response_dict = json.loads(response_json)
            reasoning = response_dict.get("reasoning", "").strip()
            code = response_dict.get("code", "").strip()
            return {"reasoning": reasoning, "code": code}
        except json.JSONDecodeError as e:
            print(f"JSON decoding failed: {e}")
            sys.exit(1)

    # Parse the agent's response
    output = parse_agent_response(structured_output)

    # Save the reasoning to a Markdown file
    if output.get("reasoning"):
        with open(output_path_markdown, "w", encoding="utf-8") as markdown_file:
            markdown_file.write(f"# Reasoning\n\n{output['reasoning']}")
    else:
        print("No reasoning was found in the agent's response.")
        sys.exit(1)

    if output.get("code"):
        print("Update output path...")
        # Update the generated code to replace the 'output_path' dynamically
        updated_code = update_output_path(output["code"], output_path_csv)

        # Create a code error
        updated_code = (
            updated_code
            + "This is a faulty comment at the end of the code and needs to be removed!"
        )

        # Initialize attempt counter
        max_attempts = 5
        attempt = 0
        success = False

        while not success and attempt < max_attempts:
            attempt += 1
            print(f"\nAttempt {attempt}: Running the script...")

            # Save the updated code to the script file
            with open(output_path_script, "w", encoding="utf-8") as script_file:
                script_file.write(updated_code)

            # Try running the script
            try:
                result = subprocess.run(
                    [sys.executable, output_path_script],
                    capture_output=True,
                    text=True,
                    check=True,
                )
                print("The script was executed successfully.")
                success = True
            except subprocess.CalledProcessError as e:
                print(f"An error occurred while executing the script: {e}")
                print("Standard output:")
                print(e.stdout)
                print("Standard error:")
                print(e.stderr)

                if attempt >= max_attempts:
                    print("Maximum number of attempts reached. Exiting.")
                    sys.exit(1)

                # Prepare the prompt to fix the code
                fix_prompt = f"""
Your task is to fix the following Python code, which produced an error when run.

The code is:
```python
{updated_code}
```

The error message is:
{e.stderr}

Please provide the corrected code and a description of the fix.


Your output must be provided in JSON format. Provide all detailed reasoning in a structured and human readable way (e.g. using sub headers, bulletpoints and numbered lists) and the pure executable Python code in the following JSON format:
{{
    "reasoning": "Your detailed description here...",
    "code": "Your corrected code here..."
}}
Ensure that the output is valid JSON and does not include any additional commentary or explanation. Do not surround the JSON output with any code block markers or tags like ```json```.
"""
                # Invoke the agent to fix the code
                fix_response = agent.invoke(fix_prompt)
                fix_response_output = fix_response.get("output")

                # Use the structured output agent to parse the fix response
                structured_fix_output = structured_output_agent.invoke(
                    fix_response_output
                )

                # Parse the response
                try:
                    # Convert the pydantic object to JSON string
                    fix_response_json = structured_fix_output.json()
                    # Load the JSON string into a dictionary
                    fix_response_dict = json.loads(fix_response_json)
                    description_of_fix = fix_response_dict.get("reasoning", "")
                    fixed_code = fix_response_dict.get("code", "")
                except json.JSONDecodeError as e_json:
                    print(f"JSON decoding failed: {e_json}")
                    sys.exit(1)

                if not fixed_code:
                    print("No fixed code was found in the agent's response.")
                    sys.exit(1)

                # Update the code for the next attempt
                updated_code = fixed_code

                # Append the description of the fix to the Markdown file
                with open(output_path_markdown, "a", encoding="utf-8") as markdown_file:
                    markdown_file.write(
                        f"\n\n# Fix Attempt {attempt}\n\n{description_of_fix}"
                    )

        if not success:
            print("Failed to execute the script after multiple attempts.")
            sys.exit(1)

    else:
        print("No Python code was found in the agent's response.")
        sys.exit(1)

    #     print("Create the script...")
    #     # Save the generated code to a Python file
    #     with open(output_path_script, "w", encoding="utf-8") as script_file:
    #         script_file.write(updated_code)

    #     # Run the generated Python script
    #     print("Attempting to run the generated script...")
    #     try:
    #         result = subprocess.run([sys.executable, output_path_script], check=True)
    #         print("The generated script was executed successfully.")
    #     except subprocess.CalledProcessError as e:
    #         print(f"An error occurred while executing the script: {e}")
    #         sys.exit(1)
    # else:
    #     print("No Python code was found in the agent's response.")
    #     sys.exit(1)
