import sys
import subprocess
import json
import requests
import pandas as pd
from state.agent_state import AgentState
from utils.create_prompt import create_prompt
from utils.agent_creation import create_coding_agent
from utils.json_output_cleaner import clean_json_output
from context.mappings.mappings_methodologies import methodologies_mapping
from utils.path_helper import get_run_path, ensure_path_exists


def get_emissionfactor_value_agent_step_4(
    state: AgentState,
):
    """
    This agent extracts the unique combinations of 'gpc_refno', 'actor_name' (region) and 'methodology_name' from the dataframe 'df'.
    Then it makes an API call for those unique combinations to get the 'emissionfactor_value' and adds it to the dataframe 'df'.

    Inputs:
        Input path to the csv file created by the prior agent.
        The dataframe loaded from the input path.
        The python script generated by the prior agent.
        Output path for the generated files.
    """
    print("\nGET EMISSIONFACTOR VALUE AGENT STEP 4\n")

    # Load the output files of initial script
    input_path_csv = get_run_path(state, "step_4/steps/extracted_methodology_name.csv")
    input_path_script = get_run_path(state, "step_4/steps/generated_script_extracted_methodology_name.py")

    # Load the csv file into the dataframe
    df = pd.read_csv(input_path_csv, encoding="utf-8")
    # Load the script
    # with open(input_path_script, "r", encoding="utf-8") as file:
    #     script = file.read()

    # Define the output paths
    output_path_csv = get_run_path(state, "step_4/steps/extracted_emissionfactor_value.csv")
    # output_path_script = get_run_path(state, "step_4/steps/generated_script_extracted_emissionfactor_value.py")
    # output_path_markdown = get_run_path(state, "step_4/steps/generated_markdown_extracted_emissionfactor_value.md")
    
    # Ensure output directory exists
    ensure_path_exists(output_path_csv)

    # Step 1: Extract unique combinations of 'actor_name', 'gpc_refno', 'methodology_name'
    # Based on implementation of API, this might need to be adjusted
    unique_combinations = df[
        ["actor_name", "gpc_refno", "methodology_name"]
    ].drop_duplicates()

    # Step 2: Define the API call using requests
    def api_call(row):
        print("Make API call...")
        actor_name = row["actor_name"]
        gpc_refno = row["gpc_refno"]
        methodology_name = row["methodology_name"]

        # Ensure required parameters are provided
        if pd.isnull(gpc_refno) or not gpc_refno.strip():
            return None
        if pd.isnull(methodology_name) or not methodology_name.strip():
            return None

        # Set actor_name to 'world' if not provided
        if pd.isnull(actor_name) or not str(actor_name).strip():
            actor_name = "world"

        # Simulate an API response
        # For the purpose of this demo, we will generate a mock response
        return f"Emission factor for {actor_name}, {gpc_refno}, {methodology_name}"

        # Set the URL endpoint
        url = "https://citycatalyst.openearth.dev/api/v0/emissions-factor"

        # Prepare the payload for the API request
        params = {
            "actor_name": actor_name,
            "referenceNumber": gpc_refno,
            "methodologyId": methodology_name,
        }

        try:
            # Make the API request
            response = requests.get(url, params=params)

            # Check if the request was successful and has content
            if response.status_code == 200 and response.text:
                return response.text
            else:
                # If the response is not successful, and actor_name is not 'world', retry with 'world'
                if actor_name != "world":
                    params["actor_name"] = "world"
                    retry_response = requests.get(url, params=params)
                    if retry_response.status_code == 200 and retry_response.text:
                        return retry_response.text
                # If no valid response, return None
                return None
        except requests.exceptions.RequestException as e:
            return None

    # Apply the 'get_X' function to the unique combinations
    unique_combinations["emissionfactor_value"] = unique_combinations.apply(
        api_call, axis=1
    )

    print(unique_combinations)
    print(unique_combinations.to_dict(orient="records"))

    # Step 3: Merge the responses back to the original DataFrame
    df_with_emissionfactor_value = df.merge(
        unique_combinations,
        on=["actor_name", "gpc_refno", "methodology_name"],
        how="left",
    )

    # For the purpose of this demo, print the result
    print(df_with_emissionfactor_value)

    # Optionally, save the resulting DataFrame
    df_with_emissionfactor_value.to_csv(output_path_csv, index=False)

    return state
